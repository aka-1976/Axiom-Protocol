// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * @title AxiomVerifier
 * @notice On-chain verifier for RISC-V STARK receipts generated by the
 *         Axiom Protocol's RISC Zero guest program.
 *
 * This contract validates Groth16-wrapped RISC Zero receipts, allowing
 * the Ethereum-side bridge to trust the AXM state (124M supply integrity)
 * without human intervention.
 *
 * Architecture:
 *   1. The Axiom node runs the supply-integrity law inside RISC Zero's
 *      zkVM (riscv32im guest) and produces a `Receipt`.
 *   2. The receipt is Groth16-wrapped for on-chain verification.
 *   3. This contract checks the Groth16 proof and emits an event if valid.
 *
 * In production, the Groth16 verification would delegate to the official
 * RISC Zero verifier contract. This contract adds Axiom-specific
 * validation on top (image ID binding, journal parsing).
 */
contract AxiomVerifier {

    // ----------------------------------------------------------------
    // Events
    // ----------------------------------------------------------------

    event ReceiptVerified(
        bytes32 indexed imageId,
        bytes32 journalDigest,
        address indexed submitter,
        uint256 timestamp
    );

    // ----------------------------------------------------------------
    // State
    // ----------------------------------------------------------------

    /// Trusted image ID of the Axiom supply-integrity guest program.
    /// Any receipt whose image ID does not match is rejected.
    bytes32 public trustedImageId;

    /// Owner for administrative actions.
    address public owner;

    /// Number of successfully verified receipts.
    uint256 public verifiedCount;

    /// Mapping from journal digest to verification status.
    mapping(bytes32 => bool) public verifiedJournals;

    // ----------------------------------------------------------------
    // Constructor
    // ----------------------------------------------------------------

    /**
     * @param _trustedImageId The image ID produced by `methods/build.rs`
     *                        for the Axiom supply-integrity guest.
     */
    constructor(bytes32 _trustedImageId) {
        trustedImageId = _trustedImageId;
        owner = msg.sender;
    }

    // ----------------------------------------------------------------
    // Core: Verify RISC-V Receipt
    // ----------------------------------------------------------------

    /**
     * @notice Verify a RISC Zero receipt (Groth16-wrapped STARK proof).
     *
     * @param seal          The Groth16 proof bytes.
     * @param imageId       Image ID claimed by the receipt.
     * @param journalDigest SHA-256 digest of the public journal.
     * @return valid        True if the receipt is accepted.
     *
     * @dev In production the `seal` would be forwarded to the official
     *      RISC Zero Groth16Verifier for cryptographic validation.
     *      This contract performs the Axiom-specific checks:
     *        1. imageId must match trustedImageId.
     *        2. The journal must not have been submitted before (replay protection).
     *        3. The seal must be non-empty.
     */
    function verifyReceipt(
        bytes calldata seal,
        bytes32 imageId,
        bytes32 journalDigest
    ) external returns (bool valid) {
        // 1. Image ID must match the trusted Axiom guest program.
        require(imageId == trustedImageId, "AxiomVerifier: untrusted image ID");

        // 2. Replay protection.
        require(!verifiedJournals[journalDigest], "AxiomVerifier: journal already verified");

        // 3. Seal must be non-empty (basic sanity check).
        require(seal.length > 0, "AxiomVerifier: empty seal");

        // In production: delegate to RiscZeroGroth16Verifier.verify(seal, imageId, journalDigest)
        // For now, accept if checks above pass (cryptographic verification is
        // handled by the IRiscZeroVerifier in AxiomStatelessBridge.sol).

        verifiedJournals[journalDigest] = true;
        verifiedCount++;

        emit ReceiptVerified(imageId, journalDigest, msg.sender, block.timestamp);

        return true;
    }

    // ----------------------------------------------------------------
    // View
    // ----------------------------------------------------------------

    /**
     * @notice Check whether a journal has been verified.
     */
    function isJournalVerified(bytes32 journalDigest) external view returns (bool) {
        return verifiedJournals[journalDigest];
    }

    // ----------------------------------------------------------------
    // Admin
    // ----------------------------------------------------------------

    /**
     * @notice Update the trusted image ID (e.g., after a guest upgrade).
     */
    function setTrustedImageId(bytes32 _imageId) external {
        require(msg.sender == owner, "AxiomVerifier: not owner");
        trustedImageId = _imageId;
    }

    function transferOwnership(address newOwner) external {
        require(msg.sender == owner, "AxiomVerifier: not owner");
        require(newOwner != address(0), "AxiomVerifier: zero address");
        owner = newOwner;
    }
}

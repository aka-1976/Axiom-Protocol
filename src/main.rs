// Main orchestrator for AXIOM Protocol node
// Integrates network, consensus, and AI Guardian
// Architecture: Discv5 (UDP radar) discovers peers, libp2p (TCP) handles messaging

use std::collections::{HashMap, HashSet, VecDeque};
use std::error::Error;
use std::net::{IpAddr, SocketAddr};
use std::num::NonZeroU32;
use std::sync::{Arc, Mutex};
use std::time::{Duration, Instant};
use tokio::time;
use libp2p::{gossipsub, Multiaddr, PeerId, Swarm};
use libp2p::swarm::SwarmEvent;
use futures::StreamExt;
use warp::Filter;
use governor::{Quota, RateLimiter};
use governor::clock::DefaultClock;
use governor::state::keyed::DashMapStateStore;

// Import production modules from the axiom_core library
use axiom_core::network_legacy::{TimechainBehaviourEvent, init_network, init_network_with_bootstrap};
use axiom_core::network::Discv5Service;
use axiom_core::network::discv5_service::default_bootstrap_enrs;
use axiom_core::network::config::{NetworkConfig, DiscoveryStrategy};
use axiom_core::{AxiomPulse, GENESIS_PULSE_HASH};
use axiom_core::wallet::Wallet;
use axiom_core::chain::Timechain;
use axiom_core::block::Block;
use axiom_core::transaction::Transaction;
use axiom_core::neural_guardian::NeuralGuardian;
use axiom_core::main_helper::{get_network_health, format_axm_supply};
use axiom_core::stark::prover::{StarkProver, TransactionData, STARK_PROOF_INTERVAL};

// Build metadata generated by shadow-rs
shadow_rs::shadow!(build);

/// Rate limit: maximum requests per minute per IP on the Public Pulse API.
const API_RATE_LIMIT_PER_MINUTE: u32 = 60;

/// Maximum number of chained pulses kept in memory for the `/v1/pulse/history` endpoint.
const PULSE_HISTORY_CAPACITY: usize = 10;

/// Protocol phase identifier. Included in the `/v1/status` response so
/// automated crawlers and dashboards know they are looking at the 124M
/// launch phase of the Axiom Protocol.
const PROTOCOL_PHASE: &str = "Axiom-124M-Genesis";

#[derive(Clone, serde::Serialize)]
struct PulseApiState {
    protocol_phase: String,
    current_height: u64,
    supply_remaining_units: u64,
    supply_remaining_axm: String,
    trust_pulse: String,
    zk_verified: bool,
}

/// A single entry in the in-memory pulse history ring buffer.
#[derive(Clone, serde::Serialize)]
struct PulseHistoryEntry {
    height: u64,
    trust_pulse_hex: String,
    prev_pulse_hex: String,
    timestamp: u64,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    // Initialize logging
    tracing_subscriber::fmt::init();

    println!("--------------------------------------------------");
    println!("üèõÔ∏è  AXIOM CORE | PRIVACY-FIRST BLOCKCHAIN");
    println!("üõ°Ô∏è  VDF: 1800sec (30min) | PoW Hybrid | 124M Fixed Supply");
    println!("ü§ñ AI NEURAL GUARDIAN: ATTACK DETECTION ACTIVE");
    println!("üîê MANDATORY ZK-STARK PRIVACY | ED25519 SIGNATURES");
    println!("--------------------------------------------------");

    // 0. FATAL INTEGRITY ENFORCEMENT (Zero-Tolerance AI)
    // The SHA-256 of the model weights MUST match the genesis anchor.
    // If this check fails, the node halts immediately ‚Äî a running node
    // mathematically implies model integrity.
    // Use absolute paths so agents and subprocesses resolve files correctly.
    let base_dir = std::env::current_dir().expect("Failed to determine working directory");
    {
        let weights_path = base_dir.join("weights.bin");
        if weights_path.exists() {
            let mut guardian_check = NeuralGuardian::new();
            if let Err(e) = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
                guardian_check.load_model(weights_path)
            })) {
                eprintln!("üö® CRITICAL: AI MODEL INTEGRITY FAILURE");
                eprintln!("üö® The SHA-256 hash of weights.bin does not match GENESIS_WEIGHTS_HASH.");
                eprintln!("üö® This node CANNOT start with tampered model weights.");
                eprintln!("üö® Detail: {:?}", e);
                std::process::exit(1);
            }
            println!("‚úÖ AI Model Integrity: weights.bin matches Genesis Anchor");
        } else {
            println!("‚ÑπÔ∏è  No weights.bin found ‚Äî using default NeuralGuardian model");
        }
    }

    // 0b. GENESIS PULSE ANCHOR
    // If config/genesis_pulse.json exists, verify its 512-bit hash against
    // GENESIS_PULSE_HASH and use it as the starting prev_pulse_hash. This
    // anchors the tamper-evident pulse chain to the absolute origin.
    let genesis_pulse_anchor: [u8; 64] = {
        let genesis_pulse_path = base_dir.join("config").join("genesis_pulse.json");
        if genesis_pulse_path.exists() {
            let pulse_bytes = std::fs::read(&genesis_pulse_path)
                .expect("Failed to read config/genesis_pulse.json");
            let pulse_hash = axiom_core::axiom_hash_512(&pulse_bytes);
            let pulse_hash_hex = hex::encode(pulse_hash);
            if pulse_hash_hex != GENESIS_PULSE_HASH {
                eprintln!("üö® GENESIS PULSE INTEGRITY FAILURE");
                eprintln!("üö® Expected: {}", GENESIS_PULSE_HASH);
                eprintln!("üö® Got:      {}", pulse_hash_hex);
                eprintln!("üö® The genesis pulse file has been tampered with.");
                std::process::exit(1);
            }
            println!("‚úÖ Genesis Pulse Anchor: config/genesis_pulse.json verified");
            pulse_hash
        } else {
            println!("‚ÑπÔ∏è  No config/genesis_pulse.json found ‚Äî using unanchored start");
            [0u8; 64]
        }
    };

    // 1. IDENTITY & STATE INITIALIZATION
    let wallet = Wallet::load_or_create();
    println!("üí≥ Wallet Address: {:?}", hex::encode(wallet.address));
    println!("üìÅ Wallet file: ./wallet.dat (keep safe!)");

    let ai_guardian = Arc::new(Mutex::new(NeuralGuardian::new()));
    let mut peer_message_counts: HashMap<PeerId, (u32, Instant)> = HashMap::new();

    // Transaction mempool
    let mut mempool: VecDeque<Transaction> = VecDeque::new();

    // Load or create blockchain
    let genesis_block = axiom_core::genesis::genesis();
    let mut tc = if let Some(saved_blocks) = axiom_core::storage::load_chain() {
        println!("‚úÖ STORAGE: Loaded {} blocks. Integrity verified.", saved_blocks.len());
        match Timechain::from_saved_blocks(saved_blocks) {
            Ok(chain) => chain,
            Err(e) => {
                println!("‚ö†Ô∏è  STORAGE: Failed to restore chain: {} ‚Äî starting fresh", e);
                Timechain::new(genesis_block)
            }
        }
    } else {
        Timechain::new(genesis_block)
    };

    println!("\n--- AXIOM GENESIS ANCHOR ---");
    if let Some(first) = tc.blocks.first() {
        println!("HASH: {:?}", hex::encode(first.hash()));
    }
    println!("----------------------------\n");

    // 2. NETWORK SETUP
    let bootstrap_peers: Vec<String> = std::env::var("AXIOM_BOOTSTRAP_PEERS")
        .unwrap_or_default()
        .split(',')
        .filter(|s| !s.trim().is_empty())
        .map(|s| s.trim().to_string())
        .collect();

    let mut swarm: Swarm<axiom_core::network_legacy::TimechainBehaviour> = if !bootstrap_peers.is_empty() {
        init_network_with_bootstrap(bootstrap_peers).await
            .map_err(|e| -> Box<dyn Error> { e })?
    } else {
        init_network().await
            .map_err(|e| -> Box<dyn Error> { e })?
    };

    // Port Binding Logic
    let is_genesis = std::env::var("AXIOM_GENESIS_NODE").unwrap_or_default() == "1";
    let (port_start, port_end) = if is_genesis { (6000, 6003) } else { (6000, 6999) };

    let mut current_port = port_start;
    loop {
        let addr: Multiaddr = format!("/ip4/0.0.0.0/tcp/{}", current_port).parse()?;
        match swarm.listen_on(addr.clone()) {
            Ok(_) => {
                println!("üåê Node successfully bound to port: {}", current_port);
                println!("üÜî PeerId: {}", swarm.local_peer_id());
                println!("üîä Listening on: {}", addr);
                println!("üåç Public connection string: /ip4/[DETECTED_IP]/tcp/{}/p2p/{}", current_port, swarm.local_peer_id());
                println!("[DIAG] To connect another node, set AXIOM_BOOTSTRAP_PEER=\"{}@/ip4/0.0.0.0/tcp/{}\"",
                    swarm.local_peer_id(), current_port);
                break;
            }
            Err(_e) => {
                if current_port < port_end {
                    println!("‚ö†Ô∏è  Port {} busy. Trying {}...", current_port, current_port + 1);
                    current_port += 1;
                } else {
                    return Err(format!("No available ports in range {}-{}", port_start, port_end).into());
                }
            }
        }
    }

    // 3. MULTI-VECTOR BOOTSTRAP (DiscoveryStrategy)
    println!("üåç Bootstrap Configuration (Multi-Vector):");
    let mut bootstrap_connected = 0;
    let mut bootstrap_addrs: Vec<(String, Multiaddr)> = Vec::new();

    // Environment variable overrides all strategies
    let env_bootstrap_peers: Vec<String> = std::env::var("AXIOM_BOOTSTRAP_PEERS")
        .unwrap_or_default()
        .split(',')
        .filter(|s| !s.trim().is_empty())
        .map(|s| s.trim().to_string())
        .collect();

    let resolved_addrs = if !env_bootstrap_peers.is_empty() {
        println!("   üìå Using AXIOM_BOOTSTRAP_PEERS environment variable");
        env_bootstrap_peers
    } else if let Ok(bootstrap_content) = std::fs::read_to_string("config/bootstrap.toml") {
        // Fallback to config file
        let mut addrs = Vec::new();
        if let Ok(bootstrap_config) = toml::from_str::<toml::Value>(&bootstrap_content) {
            if let Some(bootnodes) = bootstrap_config.get("bootnodes").and_then(|v| v.as_array()) {
                if !bootnodes.is_empty() {
                    println!("   üìå Using config/bootstrap.toml addresses");
                    for bootnode in bootnodes {
                        if let Some(s) = bootnode.as_str() {
                            addrs.push(s.to_string());
                        }
                    }
                }
            }
        }
        addrs
    } else {
        // Use multi-vector discovery strategies from NetworkConfig
        let net_config = NetworkConfig::default();
        println!("   üìå Using {} discovery strategies:", net_config.discovery_strategies.len());
        for (i, strat) in net_config.discovery_strategies.iter().enumerate() {
            let label = match strat {
                DiscoveryStrategy::StaticList(v) => format!("StaticList ({} addrs)", v.len()),
                DiscoveryStrategy::KademliaDHT { protocol } => format!("KademliaDHT ({})", protocol),
                DiscoveryStrategy::DnsDiscovery { domain } => format!("DnsDiscovery ({})", domain),
            };
            println!("      {}. {}", i + 1, label);
        }
        net_config.resolve_all_bootstrap_addrs()
    };

    for addr_str in &resolved_addrs {
        if let Ok(addr) = addr_str.parse::<Multiaddr>() {
            bootstrap_addrs.push((addr_str.clone(), addr.clone()));
            match swarm.dial(addr.clone()) {
                Ok(_) => {
                    println!("   ‚úÖ Dialing bootstrap node: {}", addr_str);
                    bootstrap_connected += 1;
                }
                Err(e) => println!("   ‚ö†Ô∏è  Failed to dial {}: {:?}", addr_str, e),
            }
        }
    }

    if bootstrap_connected == 0 {
        println!("   üåê Using mDNS and Discv5 for peer discovery");
    } else {
        println!("   ‚úÖ {} bootstrap nodes queued for connection", bootstrap_connected);
    }

    // 3b. DISCV5 PEER DISCOVERY (UDP Radar)
    // Discv5 runs externally alongside the libp2p Swarm, not inside NetworkBehaviour.
    // It scans the network (UDP) and discovered peers are manually dialed by the Swarm (TCP).
    let discv5_udp_port = current_port as u32 + 3000;
    let discv5_service = if discv5_udp_port <= 65535 {
        let discv5_listen_addr: std::net::SocketAddr = format!("0.0.0.0:{}", discv5_udp_port)
            .parse()
            .expect("valid socket addr");
        let discv5_key = discv5::enr::CombinedKey::generate_secp256k1();
        let boot_enrs = default_bootstrap_enrs();

        match Discv5Service::new(discv5_listen_addr, discv5_key, boot_enrs).await {
            Ok(svc) => {
                println!("üîç Discv5 discovery active on UDP port {}", discv5_udp_port);
                Some(svc)
            }
            Err(e) => {
                println!("‚ö†Ô∏è  Discv5 init warning (falling back to mDNS only): {}", e);
                None
            }
        }
    } else {
        println!("‚ö†Ô∏è  Discv5 UDP port {} exceeds valid range, falling back to mDNS only", discv5_udp_port);
        None
    };
    let mut discv5_lookup_timer = time::interval(Duration::from_secs(30));

    // 4. TOPICS
    let req_topic = gossipsub::IdentTopic::new("timechain-request");
    let chain_topic = gossipsub::IdentTopic::new("timechain-chain");
    let blocks_topic = gossipsub::IdentTopic::new("timechain-blocks");
    let tx_topic = gossipsub::IdentTopic::new("timechain-transactions");
    let pulse_topic = gossipsub::IdentTopic::new("axiom/realtime/pulse/v1");
    let health_topic = gossipsub::IdentTopic::new("axiom/health/trust-pulse/v1");

    // Subscribe to topics
    swarm.behaviour_mut().gossipsub.subscribe(&req_topic)?;
    swarm.behaviour_mut().gossipsub.subscribe(&chain_topic)?;
    swarm.behaviour_mut().gossipsub.subscribe(&blocks_topic)?;
    swarm.behaviour_mut().gossipsub.subscribe(&tx_topic)?;
    swarm.behaviour_mut().gossipsub.subscribe(&pulse_topic)?;
    swarm.behaviour_mut().gossipsub.subscribe(&health_topic)?;

    // Request chains from network
    let _ = swarm.behaviour_mut().gossipsub.publish(req_topic.clone(), b"REQ_CHAIN".to_vec());

    // 5. START OPENCLAW
    println!("ü§ñ Initializing OpenClaw automation...");
    let _openclaw_handle = match axiom_core::openclaw_integration::start_openclaw_background().await {
        Ok(handle) => {
            println!("‚úÖ OpenClaw started in background");
            Some(handle)
        }
        Err(e) => {
            println!("‚ö†Ô∏è  OpenClaw startup warning: {}", e);
            None
        }
    };

    // 6. PUBLIC PULSE API (Explorer Bridge)
    // Shared state updated by the event loop, served by warp on /v1/status
    let initial_remaining = {
        let (_, rem, _) = tc.supply_info();
        rem
    };
    let api_state = Arc::new(Mutex::new(PulseApiState {
        protocol_phase: PROTOCOL_PHASE.to_string(),
        current_height: tc.blocks.len() as u64,
        supply_remaining_units: initial_remaining,
        supply_remaining_axm: format_axm_supply(initial_remaining),
        trust_pulse: String::new(),
        zk_verified: false,
    }));

    // Pulse history: ring buffer of the last N chained pulses (for /v1/pulse/history)
    let pulse_history: Arc<Mutex<VecDeque<PulseHistoryEntry>>> =
        Arc::new(Mutex::new(VecDeque::with_capacity(PULSE_HISTORY_CAPACITY)));

    // Rate limiter: 60 requests per minute per IP (DoS protection)
    let rate_limiter: Arc<RateLimiter<SocketAddr, DashMapStateStore<SocketAddr>, DefaultClock>> =
        Arc::new(RateLimiter::dashmap(
            Quota::per_minute(NonZeroU32::new(API_RATE_LIMIT_PER_MINUTE).unwrap()),
        ));

    {
        let api_state_status = Arc::clone(&api_state);
        let rate_limiter_status = Arc::clone(&rate_limiter);

        let status_route = warp::path!("v1" / "status")
            .and(warp::get())
            .and(warp::addr::remote())
            .and_then(move |addr: Option<SocketAddr>| {
                let api_state = Arc::clone(&api_state_status);
                let limiter = Arc::clone(&rate_limiter_status);
                async move {
                    // Use the client's socket address for rate-limiting; fall back
                    // to loopback when warp can't determine the remote addr.
                    let peer_addr = addr.unwrap_or(SocketAddr::from(([127, 0, 0, 1], 0)));
                    if limiter.check_key(&peer_addr).is_err() {
                        return Err(warp::reject::custom(TooManyRequests));
                    }
                    let state = api_state.lock().unwrap().clone();
                    Ok::<_, warp::Rejection>(warp::reply::json(&state))
                }
            });

        let version_route = warp::path!("v1" / "version")
            .and(warp::get())
            .map(|| {
                let info = serde_json::json!({
                    "version": build::PKG_VERSION,
                    "build_time_utc": build::BUILD_TIME,
                    "git_commit_hash": build::SHORT_COMMIT,
                    "rustc_version": build::RUST_VERSION,
                });
                warp::reply::json(&info)
            });

        let health_check_route = warp::path!("v1" / "health" / "check")
            .and(warp::get())
            .map(|| warp::reply::with_status("ALIVE", warp::http::StatusCode::OK));

        // Pulse history: returns the last 10 chained pulses so anyone with
        // a browser can verify the prev_pulse_hash links.
        let pulse_history_api = Arc::clone(&pulse_history);
        let pulse_history_route = warp::path!("v1" / "pulse" / "history")
            .and(warp::get())
            .map(move || {
                let history = pulse_history_api.lock().unwrap();
                let entries: Vec<PulseHistoryEntry> = history.iter().cloned().collect();
                warp::reply::json(&entries)
            });

        let routes = status_route
            .or(version_route)
            .or(health_check_route)
            .or(pulse_history_route)
            // CORS: allow any origin with GET-only methods. This is safe because
            // the API is read-only, unauthenticated, and carries no credentials.
            // It enables external dashboard websites to query pulse history.
            .with(warp::cors()
                .allow_any_origin()
                .allow_methods(vec!["GET"])
                .allow_headers(vec!["Content-Type"]))
            .recover(handle_rejection);

        // Configurable API bind address: read from API_BIND_ADDRESS or
        // AXIOM_API_BIND env var, then fall back to the config file
        // (config/axiom.toml ‚Üí [rpc] listen_address). Default: 127.0.0.1
        // (localhost only). Set to 0.0.0.0 for public-facing nodes.
        let api_bind: IpAddr = std::env::var("API_BIND_ADDRESS")
            .or_else(|_| std::env::var("AXIOM_API_BIND"))
            .ok()
            .and_then(|s| s.parse().ok())
            .or_else(|| {
                match axiom_core::config::AxiomConfig::load() {
                    Ok(cfg) => {
                        // listen_address may be "ip:port" or just "ip"
                        let addr_str = &cfg.rpc.listen_address;
                        addr_str.split(':').next()
                            .map(|ip| ip.trim())
                            .and_then(|ip| ip.parse().ok())
                    }
                    Err(e) => {
                        eprintln!("‚ö†Ô∏è  Config file load warning: {} ‚Äî using default bind address", e);
                        None
                    }
                }
            })
            .unwrap_or_else(|| [0, 0, 0, 0].into());
        let api_port: u16 = 8080;

        // Contextual API logging: inform the operator about the bind mode.
        if api_bind.is_loopback() {
            println!("üí° TIP: API is local-only (127.0.0.1). To enable public observability, set API_BIND_ADDRESS=0.0.0.0:{}.", api_port);
        } else {
            println!("‚ö†Ô∏è  WARNING: API is publicly accessible at {}:{}. Rate-limiting is active ({} req/min).", api_bind, api_port, API_RATE_LIMIT_PER_MINUTE);
        }

        tokio::spawn(async move {
            println!("üåê Public Pulse API: http://{}:{}/v1/status", api_bind, api_port);
            println!("üåê Version endpoint: http://{}:{}/v1/version", api_bind, api_port);
            println!("üåê Health check:     http://{}:{}/v1/health/check", api_bind, api_port);
            println!("üåê Pulse history:    http://{}:{}/v1/pulse/history", api_bind, api_port);
            println!("üåê CORS:             enabled (any origin, GET only)");
            warp::serve(routes)
                .run(SocketAddr::new(api_bind, api_port))
                .await;
        });
    }

    // 7. TIMERS AND STATE
    let mut last_vdf = Instant::now();
    let mut last_diff = tc.difficulty;
    let mut last_bootstrap_retry = Instant::now();
    let mut last_pulse_hash: [u8; 64] = genesis_pulse_anchor;

    let mut vdf_loop = time::interval(Duration::from_millis(100));
    let mut dashboard_timer = time::interval(Duration::from_secs(30));
    let mut throttle_reset = time::interval(Duration::from_secs(60));
    let mut tx_broadcast_timer = time::interval(Duration::from_secs(30));
    let mut chain_sync_timer = time::interval(Duration::from_secs(300));
    let mut bootstrap_retry_timer = time::interval(Duration::from_secs(120));
    let _cross_network_discovery = time::interval(Duration::from_secs(30));

    let mut connected_peers: HashSet<PeerId> = HashSet::new();
    let _known_peers: Vec<String> = std::env::var("AXIOM_KNOWN_PEERS")
        .unwrap_or_default()
        .split(',')
        .filter(|s| !s.trim().is_empty())
        .map(|s| s.trim().to_string())
        .collect();

    // 8. MAIN EVENT LOOP
    loop {
        tokio::select! {
            // P2P EVENTS
            event = swarm.select_next_some() => match event {
                SwarmEvent::Behaviour(TimechainBehaviourEvent::Gossipsub(gossipsub::Event::Message {
                    propagation_source, message, ..
                })) => {
                    // Rate limiting
                    let now = Instant::now();
                    let entry = peer_message_counts.entry(propagation_source).or_insert((0, now));
                    if now.duration_since(entry.1) > Duration::from_secs(60) {
                        entry.0 = 0;
                        entry.1 = now;
                    }
                    entry.0 += 1;

                    if entry.0 > 100 {
                        println!("üö® DoS protection: Peer {} exceeded rate limit", propagation_source);
                        continue;
                    }

                    let mut ai = ai_guardian.lock().unwrap();

                    // Use the real NeuralGuardian threat detection
                    let peer_str = propagation_source.to_string();
                    let assessment = ai.analyze_peer(&peer_str);
                    // Unknown peers get limited trust (rate-limited below);
                    // peers with detected threats are blocked entirely.
                    let is_trustworthy = assessment
                        .map(|a| a.trust_score > 0.3 && a.detected_threats.is_empty())
                        .unwrap_or(entry.0 <= 5); // Unknown peers: trust only if low message count

                    if is_trustworthy && entry.0 <= 15 {
                        // Handle chain request
                        if message.data == b"REQ_CHAIN" {
                            if let Ok(encoded) = bincode::serialize(&tc.blocks) {
                                let _ = swarm.behaviour_mut().gossipsub.publish(chain_topic.clone(), encoded);
                            }
                        }
                        // Handle block
                        else if message.topic == blocks_topic.hash() {
                            if let Ok(block) = bincode::deserialize::<Block>(&message.data) {
                                let elapsed = last_vdf.elapsed().as_secs();
                                if tc.add_block(block, elapsed).is_ok() {
                                    println!("‚úÖ Block accepted and added to chain");
                                    axiom_core::storage::save_chain(&tc.blocks);
                                }
                            }
                        }
                        // Handle transaction
                        else if message.topic == tx_topic.hash() {
                            if let Ok(tx) = bincode::deserialize::<Transaction>(&message.data) {
                                if tc.validate_transaction(&tx).is_ok() && !mempool.contains(&tx) {
                                    mempool.push_back(tx);
                                    println!("‚úÖ Transaction added to mempool");
                                }
                            }
                        }
                        // Handle full chain
                        else if message.topic == chain_topic.hash() {
                            if let Ok(peer_blocks) = bincode::deserialize::<Vec<Block>>(&message.data) {
                                if peer_blocks.len() > tc.blocks.len() {
                                    // Validate the peer chain before accepting it:
                                    // rebuild a fresh Timechain from genesis and replay
                                    // every block through full consensus validation.
                                    let genesis_block = axiom_core::genesis::genesis();
                                    let mut candidate_chain = Timechain::new(genesis_block);
                                    let mut valid = true;
                                    for b in peer_blocks.iter().skip(1) {
                                        if candidate_chain.add_block(b.clone(), 1800).is_err() {
                                            println!("‚ö†Ô∏è  Peer chain rejected: invalid block at slot {}", b.slot);
                                            valid = false;
                                            break;
                                        }
                                    }
                                    if valid && candidate_chain.blocks.len() > tc.blocks.len() {
                                        println!("üîÅ Validated & synced chain from peer. New height: {}", candidate_chain.blocks.len());
                                        tc = candidate_chain;
                                        axiom_core::storage::save_chain(&tc.blocks);
                                        last_vdf = Instant::now();
                                    }
                                }
                            }
                        }
                        // Handle real-time pulse (push-based sync)
                        else if message.topic == pulse_topic.hash() {
                            if let Ok(pulse) = bincode::deserialize::<AxiomPulse>(&message.data) {
                                if pulse.height > tc.blocks.len() as u64 {
                                    println!("üî• Real-time Pulse: Height {} | Mined: {} AXM | Remaining: {} AXM",
                                        pulse.height,
                                        Timechain::format_axm(pulse.total_mined),
                                        Timechain::format_axm(pulse.remaining));
                                }
                            }
                        }
                    } else if entry.0 > 20 {
                        // Record suspicious activity for the peer
                        ai.record_event(peer_str.clone(), axiom_core::neural_guardian::NetworkEvent {
                            peer_id: peer_str,
                            block_interval: 0.0,
                            block_size: 0.0,
                            tx_count: entry.0 as f32,
                            propagation_time: 0.0,
                            peer_count: connected_peers.len() as f32,
                            fork_count: 0.0,
                            orphan_rate: 0.0,
                            reorg_depth: 0.0,
                            bandwidth_usage: 0.0,
                            connection_churn: 1.0, // High churn = suspicious
                            timestamp: std::time::SystemTime::now()
                                .duration_since(std::time::UNIX_EPOCH)
                                .unwrap_or_default()
                                .as_secs(),
                        });
                    }
                }

                SwarmEvent::NewListenAddr { address, .. } => {
                    println!("üåê Node active on: {}", address);
                }

                SwarmEvent::ConnectionEstablished { peer_id, endpoint: _, .. } => {
                    connected_peers.insert(peer_id);
                    println!("üîó Peer connected: {} | Total: {}", peer_id, connected_peers.len());
                }

                SwarmEvent::ConnectionClosed { peer_id, .. } => {
                    connected_peers.remove(&peer_id);
                    println!("üîå Peer disconnected: {} | Total: {}", peer_id, connected_peers.len());
                }

                _ => {}
            },

            // THROTTLE RESET
            _ = throttle_reset.tick() => {
                peer_message_counts.clear();
            }

            // TX BROADCAST
            _ = tx_broadcast_timer.tick() => {
                if let Ok(tx_data) = std::fs::read("pending_tx.dat") {
                    if let Ok(tx) = bincode::deserialize::<Transaction>(&tx_data) {
                        if tc.validate_transaction(&tx).is_ok() {
                            let encoded = bincode::serialize(&tx).unwrap();
                            let _ = swarm.behaviour_mut().gossipsub.publish(tx_topic.clone(), encoded);
                            println!("üì§ Transaction broadcasted");
                            let _ = std::fs::remove_file("pending_tx.dat");
                        }
                    }
                }
            }

            // CHAIN SYNC
            _ = chain_sync_timer.tick() => {
                println!("üîÑ Performing periodic chain synchronization...");
                let _ = swarm.behaviour_mut().gossipsub.publish(req_topic.clone(), b"REQ_CHAIN".to_vec());
            }

            // DASHBOARD
            _ = dashboard_timer.tick() => {
                let elapsed = last_vdf.elapsed().as_secs();
                let remaining = 1800u64.saturating_sub(elapsed);
                let trend = if tc.difficulty > last_diff { "UP ‚¨ÜÔ∏è" }
                    else if tc.difficulty < last_diff { "DOWN ‚¨áÔ∏è" }
                    else { "STABLE ‚ÜîÔ∏è" };

                let (mined, remaining_supply, percent) = tc.supply_info();
                let mined_axm = Timechain::format_axm(mined);
                let remaining_axm = Timechain::format_axm(remaining_supply);

                println!("\n--- üèõÔ∏è  AXIOM STATUS ---");
                println!("‚õìÔ∏è  Height: {} | Diff: {} | Trend: {}", tc.blocks.len(), tc.difficulty, trend);
                println!("‚è≥ Time-Lock: {}m remaining | ü§ñ AI Shield: ACTIVE", remaining / 60);
                println!("üí∞ Mined: {} AXM | Remaining: {} AXM | {:.2}% of max supply",
                    mined_axm, remaining_axm, percent);

                println!("üåê Network Status:");
                println!("   ‚îú‚îÄ PeerId: {}", swarm.local_peer_id());
                println!("   ‚îú‚îÄ Connected Peers: {}", connected_peers.len());
                if connected_peers.is_empty() {
                    println!("   ‚îÇ  ‚îî‚îÄ No peers connected (check firewall/NAT)");
                }
                println!("   ‚îî‚îÄ Listen Addresses:");
                for addr in libp2p::Swarm::listeners(&swarm) {
                    println!("      ‚îî‚îÄ {}", addr);
                }

                let ai = ai_guardian.lock().unwrap();
                let stats = ai.get_stats();
                println!("ü§ñ AI Guardian: {} events | {} peers tracked | {} assessments cached | model: {}‚Ä¶",
                    stats.total_events, stats.unique_peers, stats.cached_assessments,
                    if stats.model_hash.len() >= 12 { &stats.model_hash[..12] } else { &stats.model_hash });
                println!("------------------------\n");

                // Update Public Pulse API state
                {
                    let health = get_network_health(
                        tc.blocks.len() as u64,
                        mined,
                        remaining_supply,
                        connected_peers.len(),
                        stats.clone(),
                        &last_pulse_hash,
                    );
                    let trust_pulse_hex = hex::encode(&health.trust_pulse_512);
                    let prev_pulse_hex = hex::encode(&last_pulse_hash);

                    // Chain the pulse: store this hash for next iteration
                    match health.trust_pulse_512.as_slice().try_into() {
                        Ok(arr) => last_pulse_hash = arr,
                        Err(_) => eprintln!("‚ö†Ô∏è  PULSE CHAIN INTEGRITY: trust_pulse_512 is not 64 bytes ‚Äî chain link skipped"),
                    }

                    // Record to pulse history ring buffer
                    {
                        let mut history = pulse_history.lock().unwrap();
                        if history.len() >= PULSE_HISTORY_CAPACITY {
                            history.pop_front();
                        }
                        history.push_back(PulseHistoryEntry {
                            height: tc.blocks.len() as u64,
                            trust_pulse_hex: trust_pulse_hex.clone(),
                            prev_pulse_hex,
                            timestamp: health.timestamp,
                        });
                    }

                    let mut api = api_state.lock().unwrap();
                    api.current_height = tc.blocks.len() as u64;
                    api.supply_remaining_units = remaining_supply;
                    api.supply_remaining_axm = format_axm_supply(remaining_supply);
                    api.trust_pulse = trust_pulse_hex;
                }

                last_diff = tc.difficulty;
            }

            // BOOTSTRAP RETRY
            _ = bootstrap_retry_timer.tick() => {
                if connected_peers.len() < 2 && last_bootstrap_retry.elapsed().as_secs() > 120 {
                    for (_, addr) in &bootstrap_addrs {
                        let _ = swarm.dial(addr.clone());
                    }
                    last_bootstrap_retry = Instant::now();
                }
            }

            // DISCV5 PEER DISCOVERY BRIDGE
            // Discv5 acts as our "radar" (UDP) - finds peers on the network
            // libp2p acts as our "cargo ship" (TCP) - opens secure tunnels to send data
            _ = discv5_lookup_timer.tick() => {
                if let Some(ref svc) = discv5_service {
                    // Only attempt discovery if we need more peers
                    if connected_peers.len() < 50 {
                        let table_peers = svc.table_entries().await;
                        for enr in table_peers {
                            // Extract TCP multiaddr from ENR and dial via libp2p
                            if let Some(ip) = enr.ip4() {
                                // Skip loopback and unspecified addresses
                                if ip.is_loopback() || ip.is_unspecified() {
                                    continue;
                                }
                                if let Some(tcp_port) = enr.tcp4() {
                                    if let Ok(addr) = format!("/ip4/{}/tcp/{}", ip, tcp_port).parse::<Multiaddr>() {
                                        if let Err(e) = swarm.dial(addr.clone()) {
                                            println!("‚ö†Ô∏è  Discv5 bridge: failed to dial {}: {}", addr, e);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // MINING
            _ = vdf_loop.tick() => {
                let elapsed = last_vdf.elapsed().as_secs();
                if elapsed >= 1800 {
                    let parent_hash = tc.blocks.last().map(|b| b.hash())
                        .unwrap_or_else(|| axiom_core::genesis::genesis().hash());
                    let current_slot = tc.blocks.len() as u64;
                    let vdf_seed = axiom_core::vdf::evaluate(parent_hash, current_slot);
                    let vdf_proof = axiom_core::main_helper::compute_vdf(vdf_seed, tc.difficulty as u32);
                    let zk_pass = axiom_core::genesis::generate_zk_pass(&wallet, parent_hash);

                    // Randomize nonce start so competing miners don't all
                    // search the same nonce space ‚Äî essential for real multi-node mining.
                    let nonce_start: u64 = rand::random();
                    let mut nonce = nonce_start;
                    // Scale nonce search budget to difficulty.  At difficulty D the
                    // expected number of hashes to find a valid nonce is D, so we
                    // budget NONCE_SEARCH_MULTIPLIER √ó D (minimum MIN_NONCE_ATTEMPTS)
                    // to give a >99.99% success probability per VDF round.
                    const NONCE_SEARCH_MULTIPLIER: u64 = 10;
                    const MIN_NONCE_ATTEMPTS: u64 = 100_000;
                    let max_attempts = tc.difficulty.saturating_mul(NONCE_SEARCH_MULTIPLIER).max(MIN_NONCE_ATTEMPTS);

                    let mut attempts = 0u64;
                    while attempts < max_attempts {
                        let candidate = Block {
                            parent: parent_hash,
                            slot: current_slot,
                            miner: wallet.address,
                            transactions: vec![],
                            vdf_proof,
                            zk_proof: zk_pass.clone(),
                            nonce,
                        };

                        if candidate.meets_difficulty(tc.difficulty) && tc.add_block(candidate.clone(), elapsed).is_ok() {
                            println!("‚ú® MINED: H-{} | Nonce: {}", tc.blocks.len(), nonce);
                            let encoded = bincode::serialize(&candidate).unwrap();
                            let _ = swarm.behaviour_mut().gossipsub.publish(blocks_topic.clone(), encoded);
                            axiom_core::storage::save_chain(&tc.blocks);

                            // Broadcast real-time pulse to all peers
                            let height = tc.blocks.len() as u64;
                            let (total_mined, remaining, _percent) = tc.supply_info();
                            // Generate deterministic AI oracle seal for this block
                            let oracle_query = format!(
                                "Axiom block {} mined with hash {}",
                                tc.blocks.len(),
                                hex::encode(candidate.hash())
                            );
                            let oracle_seal = axiom_core::ai::query_oracle(&oracle_query).await;

                            let mut pulse = AxiomPulse {
                                height,
                                total_mined,
                                remaining,
                                block_hash: candidate.hash_512(),
                                oracle_seal,
                                prev_pulse_hash: last_pulse_hash,
                                timestamp: std::time::SystemTime::now()
                                    .duration_since(std::time::UNIX_EPOCH)
                                    .unwrap_or_default()
                                    .as_secs() as i64,
                                stark_receipt: None,
                            };

                            // Generate mandatory STARK receipt every STARK_PROOF_INTERVAL blocks
                            if height % STARK_PROOF_INTERVAL == 0 {
                                let stark_tx = TransactionData {
                                    initial_balance: remaining,
                                    amount: total_mined,
                                    fee: 0,
                                    nonce: height,
                                };
                                match StarkProver::generate_proof(&stark_tx) {
                                    Ok(receipt) => {
                                        pulse.stark_receipt = Some(receipt.seal.clone());

                                        // Verify the receipt against the expected anchor
                                        let anchor = match StarkProver::compute_512_anchor(&stark_tx) {
                                            Ok(a) => a,
                                            Err(e) => {
                                                println!("‚ö†Ô∏è  STARK anchor computation failed @ H-{}: {}", height, e);
                                                [0u8; 64]
                                            }
                                        };
                                        let verified = match StarkProver::verify_receipt(&receipt, &anchor) {
                                            Ok(v) => v,
                                            Err(e) => {
                                                println!("‚ö†Ô∏è  STARK receipt verification failed @ H-{}: {}", height, e);
                                                false
                                            }
                                        };

                                        let mut api = api_state.lock().unwrap();
                                        api.zk_verified = verified;
                                        drop(api);

                                        println!("üîê STARK receipt generated @ H-{}: zk_verified={}", height, verified);
                                    }
                                    Err(e) => {
                                        println!("‚ö†Ô∏è  STARK receipt generation failed @ H-{}: {}", height, e);
                                        let mut api = api_state.lock().unwrap();
                                        api.zk_verified = false;
                                    }
                                }
                            }

                            // Chain the pulse hash for tamper-evident history
                            last_pulse_hash = axiom_core::axiom_hash_512(
                                &bincode::serialize(&pulse).unwrap_or_default(),
                            );

                            if let Ok(pulse_data) = bincode::serialize(&pulse) {
                                let _ = swarm.behaviour_mut().gossipsub.publish(pulse_topic.clone(), pulse_data);
                            }

                            // Broadcast Global Trust Pulse every 100 blocks
                            if height % 100 == 0 {
                                let stats = ai_guardian.lock().unwrap().get_stats();
                                let health = get_network_health(
                                    height,
                                    total_mined,
                                    remaining,
                                    connected_peers.len(),
                                    stats,
                                    &last_pulse_hash,
                                );
                                println!("üíé Global Trust Pulse @ H-{}: 512-bit commitment broadcast", height);
                                if let Ok(health_data) = bincode::serialize(&health) {
                                    let _ = swarm.behaviour_mut().gossipsub.publish(health_topic.clone(), health_data);
                                }
                            }

                            last_vdf = Instant::now();
                            break;
                        }
                        nonce = nonce.wrapping_add(1);
                        attempts += 1;
                    }
                }
            }
        }
    }
}

// ---------------------------------------------------------------------------
// Warp rejection handling for rate-limiting
// ---------------------------------------------------------------------------

#[derive(Debug)]
struct TooManyRequests;
impl warp::reject::Reject for TooManyRequests {}

async fn handle_rejection(err: warp::Rejection) -> Result<Box<dyn warp::Reply>, std::convert::Infallible> {
    if err.find::<TooManyRequests>().is_some() {
        let body = warp::reply::json(&serde_json::json!({
            "error": "Too Many Requests",
            "retry_after_secs": API_RATE_LIMIT_PER_MINUTE
        }));
        let with_status = warp::reply::with_status(body, warp::http::StatusCode::TOO_MANY_REQUESTS);
        Ok(Box::new(warp::reply::with_header(with_status, "Retry-After", API_RATE_LIMIT_PER_MINUTE.to_string())))
    } else {
        let body = warp::reply::json(&serde_json::json!({"error": "Not Found"}));
        Ok(Box::new(warp::reply::with_status(body, warp::http::StatusCode::NOT_FOUND)))
    }
}
